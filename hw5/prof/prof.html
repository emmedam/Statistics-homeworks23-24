<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <!-- <script src="MyDistributionUtilities.js"></script> -->

  <title>HW5</title>

</head>
<body>


<form id="Form">
    <label for="inputTimes">Number of attacks:</label>
    <input type="number" id="inputTimes" value=100 min="10" max="10000" step="10">
    <br></br>
    <label for="inputPaths">Number of systems:</label>
    <input type="number" id="inputPaths" value=30 min="10" max="10000" step="10">
    <br></br>
    <!-- <label for="inputMu">μ (drift):</label>
    <input type="number" id="inputMu" value=0 min="-20" max="20" step=".1">
    <br></br> -->
    <label for="inputSigma">σ (diffusion):</label>
    <input type="number" id="inputSigma" value=1 min="0.1" max="1000" step=".1">
    <br></br>
    <label for="inputLambda">λ:</label>
    <input type="number" id="inputLambda" value=50 min="1" max="1000" step="1">
    <br></br>
    <button id="buttonRecompute" type="button" style="margin-left: 10px; margin-right: 20px">Generate new</button>
</form>


<hr>
<canvas id="myCanvas" width="900" height="600" ></canvas>

<script>

    "use strict";

    class MyDistributionUtilities {

        static round2digits(myValue) {
            return Math.round((myValue + Number.EPSILON) * 100) / 100;
        }


        static UpdateMeanAndSS(x, i, [mean, ss]) {
            const oldDeviate = x - mean;
            mean += oldDeviate / i;                   //knuth
            ss += (x - mean) * oldDeviate;   //welford
            return [mean, ss];
        }


        static maxCountInIntervals(x_intervals) {
            let maxCount_x = 0;
            for (let classInterval of x_intervals) {
                if (classInterval.count > maxCount_x) {
                maxCount_x = classInterval.count
                }
            }
            return maxCount_x;
        }

        static creaPrimoIntervallo(x, intervalSize) {
            const lower = Math.floor(x * (1 / intervalSize)) * intervalSize;
            let x0_interval = new ClassInterval(
                lower,
                lower + intervalSize);
            x0_interval.count = 1;
            return x0_interval;
        }


        static allocateValueInIntervals(x, x_intervals, intervalSize) {

            if (x_intervals.length === 0) {
                x_intervals.push(this.creaPrimoIntervallo(x, intervalSize));
                return;
            }

            let x_interval = x_intervals[0];
            if (x > x_interval.lower && x <= x_interval.upper) {
                x_interval.count++;
                return x_interval.lower;
            }

            if (x <= x_interval.lower) {
                let currentIntervalIndex = 0;

                //ricerca a sinistra
                while (true) {
                    let xLeft_interval = x_intervals[currentIntervalIndex - 1];
                    if (!xLeft_interval) {
                        //creato se non esiste
                        xLeft_interval = new ClassInterval(x_interval.lower - intervalSize, x_interval.lower);
                        x_intervals.unshift(xLeft_interval);
                        currentIntervalIndex = 0;   //ultimo inserito a sinistra
                    }
                    if (x > xLeft_interval.lower && x <= xLeft_interval.upper) {
                        xLeft_interval.count++;
                        return xLeft_interval.lower;
                    }
                    x_interval = xLeft_interval;
                    currentIntervalIndex--;
                }

            } else if (x > x_interval.upper) {
                let currentIntervalIndex = 0;

                //ricerca a destra
                while (true) {
                    let xRight_interval = x_intervals[currentIntervalIndex + 1];
                    if (!xRight_interval) {
                        //creato se non esiste
                        xRight_interval = new ClassInterval(x_interval.upper, x_interval.upper + intervalSize);
                        x_intervals.push(xRight_interval);
                        currentIntervalIndex = x_intervals.length - 1;
                    }
                    if (x > xRight_interval.lower && x <= xRight_interval.upper) {
                        xRight_interval.count++;
                        return xRight_interval.lower;
                    }
                    x_interval = xRight_interval;
                    currentIntervalIndex++;
                }
            }
        }
    }

    class ClassInterval {

        lower;
        upper;
        count;
        relativeFreq;

        constructor(lower, upper) {
        this.lower = lower;
        this.upper = upper;       //included
        this.count = 0;
        this.relativeFreq = 0;
        }

    }

    class Rettangolo {

        constructor(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }

        left() {
            return this.x
        }

        top() {
            return this.y
        }

        right() {
            return this.x + this.width
        }

        bottom() {
            return this.y + this.height
        }

        // aspectRatio() {
        //     return this.width / this.height || 1
        
        // }


        disegnaRettangolo(ctx, Colore, Spessore, lineDash) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(this.x, this.y, this.width, this.height);
            ctx.strokeStyle = Colore;
            ctx.lineWidth = Spessore;
            ctx.setLineDash(lineDash);
            ctx.stroke();
            ctx.restore()

        }

        contains(x, y) {
            let lowerX = Math.min(this.left(), this.right());
            let UpperX = Math.max(this.left(), this.right());

            let lowerY = Math.min(this.top(), this.bottom());
            let UpperY = Math.max(this.top(), this.bottom());

            if ( x > lowerX && x < UpperX && y > lowerY && y < UpperY )  {
                return true
            }
        }
    }

    class My2dUtilities {

        // static transformXYIntoViewport([x, y], rectWorld, rectView) {
        
        //     return (
        //         [
        //         My2dUtilities.transformX(x, rectWorld.x, rectWorld.width, rectView.x, rectView.width),
        //         My2dUtilities.transformY(y, rectWorld.y - rectWorld.height, rectWorld.height, rectView.y, rectView.height)
        //         ]
        //     )
        // }

        static transformXYToViewport([x, y], min_x, range_x, min_y, range_y, rectView) {
            return (
                [
                My2dUtilities.transformX(x, min_x, range_x, rectView.x, rectView.width),
                My2dUtilities.transformY(y, min_y, range_y, rectView.y, rectView.height)
                ]
            )
        }


        static transformX(x, min_x, range_x, left, width) {
            return left + width * (x - min_x) / range_x;
        }

        static transformY(y, min_y, range_y, top, height) {
            return top + height - (height * (y - min_y) / range_y);
        }
    }

    const buttonRecompute = document.getElementById("buttonRecompute");
    // const inputMu = document.getElementById("inputMu");
    const inputSigma = document.getElementById("inputSigma");
    const inputLambda = document.getElementById("inputLambda");
    const inputTimes = document.getElementById("inputTimes");
    const inputPaths = document.getElementById("inputPaths");

  

    const myCanvas = document.getElementById("myCanvas");
    const ctx = myCanvas.getContext("2d");

    let sigma, lambda, n;
    let numberOfSamplePaths;
    let allPaths;
    let myRandomJump;
    let myVariate;
    // let representAsScalingLimit;
    //let myProcessValueType;
    //let myProcessValueDescription;
    let myVariate_MinView;
    let myVariate_MaxView;
    let myProcessValue_Range;
    let intervalSize;
    let NumberOfClasses;
    let x_Origin;
    let y_Origin;
    let timeForHistogram_t;
    let timeForHistogram_n;
    let avgAtLastTime;              //media della variata al tempo n
    let ssAtLastTime;               //somma quadrati della variata al tempo n
    let intervals_t;                //intervalli per distribuzione tempo intermedio
    let intervals_n;                //intervalli per distribuzione tempo finale
    let MyTimer;
    //let representAsAnimation;
    let currentPathNumber;

    const rectChart = new Rettangolo(20, 30, myCanvas.width - 200, myCanvas.height - 30 - 40);

    buttonRecompute.onclick = mainTask;

    mainTask();

    function acquisizioneScelteUtente() {

        //mu = Number(inputMu.value);
        sigma = Number(inputSigma.value);
        lambda = Number(inputLambda.value);
        n = Math.round(Number(inputTimes.value));  //forzo conversione intero per assicurare l'uguaglianza con l'indice t del loop
        numberOfSamplePaths = Number(inputPaths.value);
        NumberOfClasses = Math.max(100, numberOfSamplePaths / 60);

        timeForHistogram_t = Math.round(n / 2);
        timeForHistogram_n = n;
        //representAsAnimation = check_ANIMATED.checked;

        const sigmaMultipleForRange = 4;

        const dt = 1 / n;
        const sigma_sqrt_dt = sigma * Math.sqrt(dt);          //varianza proporzionale al tempo
        const sqrt_dt = Math.sqrt(dt);              //caso di sigma=1


        // representAsScalingLimit = false;
        myVariate_MinView = 0;
        myVariate_MaxView = lambda * 1.5;
        myRandomJump = () => (Math.random() <= (lambda / n)) ? 1 : 0;
        myVariate = (sumOfJumps) => (sumOfJumps);
    

        myProcessValue_Range = myVariate_MaxView - myVariate_MinView;
        intervalSize = myProcessValue_Range / NumberOfClasses;

        [x_Origin, y_Origin] = My2dUtilities.transformXYToViewport([0, 0], 0, n, myVariate_MinView, myProcessValue_Range, rectChart);

    }

    function mainTask() {

        clearInterval(MyTimer);
        acquisizioneScelteUtente();     //acquisizione nuove scelte
        intervals_t = [];               //intervalli per distribuzione tempo intermedio
        intervals_n = [];               //intervalli per distribuzione tempo finale
        //currentPathNumber = 0;
        //avgAtLastTime = 0;              //media della variata al tempo n
        //ssAtLastTime = 0;               //somma quadrati della variata al tempo n
        ctx.clearRect(0, 0, myCanvas.width, myCanvas.height);
        allPaths = [];


        for (let s = 1; s <= numberOfSamplePaths; s++) {
            const newPath = createSinglePath(s);
            allPaths.push(newPath);
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#' + (0x1000000 + Math.random() * 0xffffff).toString(16).substr(1, 6);   
            ctx.stroke(newPath);
        }

        sovrapponiIstogrammi();
        creaTaccheELegenda();

    }
    
   

    function sovrapponiIstogrammi() {

        //rettangolo contenitore istogramma
        const rettangoloIstogramma_t = new Rettangolo(My2dUtilities.transformX(timeForHistogram_t, 0, n, rectChart.x, rectChart.width), rectChart.y, 150, rectChart.height);
        const rettangoloIstogramma_n = new Rettangolo(My2dUtilities.transformX(timeForHistogram_n, 0, n, rectChart.x, rectChart.width), rectChart.y, 150, rectChart.height);
        rettangoloIstogramma_t.disegnaRettangolo(ctx, "rgba(100,100,250,0.5)", 2, [1, 1]);
        rettangoloIstogramma_n.disegnaRettangolo(ctx, "rgba(250,100,150,0.5)", 2, [1, 1]);

        //istogrammi
        verticalHistoFromIntervals(ctx, intervals_t, myVariate_MinView, myVariate_MaxView - myVariate_MinView, rettangoloIstogramma_t, "red", 1, "yellow");
        verticalHistoFromIntervals(ctx, intervals_n, myVariate_MinView, myVariate_MaxView - myVariate_MinView, rettangoloIstogramma_n, "red", 1, "yellow");

    }

    function verticalHistoFromIntervals(ctx, intervals, y_min, y_range, viewRect, strokeStyle, lineWidth, fillStyle) {

        //max freq
        let maxcount = 0;
        for (const interval of intervals) {
            maxcount = Math.max(maxcount, interval.count);
        }

        //isto orizzontale

        for (const interval of intervals) {

            let x_rect = viewRect.x;
            let width_rect = viewRect.width * interval.count / maxcount;

            let y_rect_top = My2dUtilities.transformY(interval.upper, y_min, y_range, viewRect.y, viewRect.height);
            let y_rect_bottom = My2dUtilities.transformY(interval.lower, y_min, y_range, viewRect.y, viewRect.height);
            let height_rect = y_rect_bottom - y_rect_top;   //y crescono verso il basso

            let rectInterval = new Rettangolo(x_rect, y_rect_top, width_rect, height_rect);

        
            ctx.rect(rectInterval.x, rectInterval.y, rectInterval.width, rectInterval.height);
            const gradient = ctx.createLinearGradient(rectInterval.x, rectInterval.y, rectInterval.x, rectInterval.y + rectInterval.height);
            gradient.addColorStop(0, 'black');
            gradient.addColorStop(0.25, fillStyle);
            gradient.addColorStop(0.5, 'white');
            gradient.addColorStop(0.75, fillStyle);
            gradient.addColorStop(1, 'black');
            ctx.fillStyle = gradient;
            ctx.fillRect(rectInterval.x, rectInterval.y, rectInterval.width, rectInterval.height);

      
        }

    }

    function createSinglePath(s) {

        currentPathNumber = s;
        const myPath = new Path2D();

        let sumOfJumps = 0;
        let previousY_Variate = y_Origin;

        myPath.moveTo(x_Origin, y_Origin);   //visualmente facciamo partire la path dall'origine

        for (let t = 1; t <= n; t++) {

            sumOfJumps += myRandomJump();
            let myProcessValue = myVariate(sumOfJumps, t);

            //raccolta valori per istogramma
            if (t === timeForHistogram_t) {
                MyDistributionUtilities.allocateValueInIntervals(myProcessValue, intervals_t, intervalSize);
            } else if (t === timeForHistogram_n) {
                MyDistributionUtilities.allocateValueInIntervals(myProcessValue, intervals_n, intervalSize);
                [avgAtLastTime, ssAtLastTime] = MyDistributionUtilities.UpdateMeanAndSS(myProcessValue, s, [avgAtLastTime, ssAtLastTime]);
            }

            const ascissa_t = My2dUtilities.transformX(t / n, 0, 1, rectChart.x, rectChart.width);

            //const ascissa_t = My2dUtilities.transformX(t, 0, n, rectChart.x, rectChart.width);
            const ordinata = My2dUtilities.transformY(myProcessValue, myVariate_MinView, myProcessValue_Range, rectChart.y, rectChart.height);

            //scalino mantenendo quota precedente
            myPath.lineTo(ascissa_t, previousY_Variate);
            //salva quota per prossimo scalino
            previousY_Variate = ordinata;

            myPath.lineTo(ascissa_t, ordinata);
        }

        return myPath;

    }

   

    function creaTaccheELegenda() {

        //rettangolo simulazione
        rectChart.disegnaRettangolo(ctx, "black", 2, []);

        //label riferimenti numerici range, media, sigma della variata
        // ctx.font = "11px Verdana";
        // ctx.fillStyle = "black";
        //ctx.fillText(myVariate_MaxView.toFixed(1), rectChart.right() + 10, rectChart.y - 7);
        //ctx.fillText(myVariate_MinView.toFixed(1), rectChart.right() + 10, rectChart.bottom() - 7);
        //ctx.fillStyle = "black";
        //ctx.fillText(myProcessValueDescription, rectChart.x + 100, rectChart.y + 15);

        //tacche tempi/trials e tempi

        ctx.beginPath();

        // if (representAsScalingLimit) {      //scaling limit: 0 -- 1
        //     ctx.fillStyle = "black";
        //     ctx.strokeStyle = "black";
        //     for (let t = 0; t <= 1; t += 0.1) {
        //         let ascissa_t = My2dUtilities.transformX(t, 0, 1, rectChart.x, rectChart.width);
        //         ctx.moveTo(ascissa_t, rectChart.bottom() - 3);
        //         ctx.lineTo(ascissa_t, rectChart.bottom() + 3);
        //         ctx.fillText(t.toFixed(1).toString(), ascissa_t - 5, rectChart.bottom() + 15);
        //     }

        // } else {

            ctx.fillStyle = "black";
            ctx.strokeStyle = "black";
            const step = 10 ** Math.round(Math.log10(n) - 1);
            for (let t = 0; t <= n; t += step) {
                let ascissa_t = My2dUtilities.transformX(t, 0, n, rectChart.x, rectChart.width);
                ctx.moveTo(ascissa_t, rectChart.bottom() - 3);
                ctx.lineTo(ascissa_t, rectChart.bottom() + 3);
                ctx.fillText(t.toFixed(1).toString(), ascissa_t - 5, rectChart.bottom() + 15);
            }
        // }
        ctx.stroke();

    }

        
</script>

</body>
</html>
